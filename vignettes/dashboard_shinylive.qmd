---
title: "Irish Weather Buoy Explorer"
format:
  html:
    page-layout: full
    embed-resources: false
    include-in-header:
      - text: |
          <script>
          // Fix serviceworker_dir meta tag BEFORE Shinylive loads
          (function() {
            var meta = document.querySelector('meta[name="shinylive:serviceworker_dir"]');
            if (meta) {
              meta.setAttribute('content', '.');
            } else {
              meta = document.createElement('meta');
              meta.name = 'shinylive:serviceworker_dir';
              meta.content = '.';
              document.head.appendChild(meta);
            }
          })();

          // Fetch buoy data and pass to Shiny
          window.BUOY_DATA = null;
          window.DATA_LOADED = false;

          function sendDataToShiny() {
            if (window.BUOY_DATA && window.Shiny && window.Shiny.setInputValue) {
              // Send the data as JSON string to R
              window.Shiny.setInputValue('js_buoy_data', JSON.stringify(window.BUOY_DATA), {priority: 'event'});
              window.Shiny.setInputValue('data_loaded', true, {priority: 'event'});
              console.log('Data sent to Shiny: ' + window.BUOY_DATA.time.length + ' records');
              window.DATA_LOADED = true;
            }
          }

          fetch('data/buoy_data.json')
            .then(response => {
              if (!response.ok) throw new Error('HTTP ' + response.status);
              return response.json();
            })
            .then(data => {
              window.BUOY_DATA = data;
              console.log('Loaded ' + data.time.length + ' buoy records from JSON');
              sendDataToShiny();
              // Retry sending if Shiny not ready yet
              if (!window.DATA_LOADED) {
                setTimeout(sendDataToShiny, 1000);
                setTimeout(sendDataToShiny, 3000);
                setTimeout(sendDataToShiny, 5000);
              }
            })
            .catch(err => {
              console.error('Failed to load buoy data:', err);
              window.BUOY_DATA = null;
            });

          // Also try when Shiny connects
          document.addEventListener('shiny:connected', function() {
            console.log('Shiny connected, sending data...');
            sendDataToShiny();
          });

          // TableSorter functionality for sortable tables
          document.addEventListener('DOMContentLoaded', function() {
            // Add click handlers to table headers for sorting
            document.addEventListener('click', function(e) {
              if (e.target.tagName === 'TH' && e.target.closest('table.sortable')) {
                var th = e.target;
                var table = th.closest('table');
                var tbody = table.querySelector('tbody');
                var rows = Array.from(tbody.querySelectorAll('tr'));
                var colIndex = Array.from(th.parentNode.children).indexOf(th);
                var isAsc = th.classList.contains('asc');

                // Sort rows
                rows.sort(function(a, b) {
                  var aVal = a.children[colIndex].textContent.trim();
                  var bVal = b.children[colIndex].textContent.trim();
                  var aNum = parseFloat(aVal);
                  var bNum = parseFloat(bVal);

                  if (!isNaN(aNum) && !isNaN(bNum)) {
                    return isAsc ? bNum - aNum : aNum - bNum;
                  }
                  return isAsc ? bVal.localeCompare(aVal) : aVal.localeCompare(bVal);
                });

                // Update classes
                th.parentNode.querySelectorAll('th').forEach(function(t) {
                  t.classList.remove('asc', 'desc');
                });
                th.classList.add(isAsc ? 'desc' : 'asc');

                // Reorder rows
                rows.forEach(function(row) { tbody.appendChild(row); });
              }
            });
          });
          </script>
          <style>
          table.sortable th {
            cursor: pointer;
            user-select: none;
            position: relative;
            padding-right: 18px !important;
          }
          table.sortable th:hover {
            background-color: #f0f0f0;
          }
          table.sortable th::after {
            content: '⇅';
            position: absolute;
            right: 4px;
            opacity: 0.3;
          }
          table.sortable th.asc::after {
            content: '↑';
            opacity: 1;
          }
          table.sortable th.desc::after {
            content: '↓';
            opacity: 1;
          }
          </style>
    resources:
      - shinylive-sw.js
      - data/buoy_data.json
      - data/stations.json
filters:
  - shinylive
---

```{shinylive-r}
#| standalone: true
#| viewerHeight: 850

# Core packages
library(shiny)
library(jsonlite)

# Install ggplot2 dependencies for plotly
tryCatch({
  if (!requireNamespace("munsell", quietly = TRUE)) {
    webr::install("munsell", repos = "https://repo.r-wasm.org")
  }
  if (!requireNamespace("ggplot2", quietly = TRUE)) {
    webr::install("ggplot2", repos = "https://repo.r-wasm.org")
  }
  library(plotly)
  library(dplyr)
}, error = function(e) {
  message("Package loading error: ", e$message)
})

# Variable choices for dropdowns
VAR_CHOICES <- c(
  "Wave Height (m)" = "wave_height",
  "Max Wave Height (m)" = "hmax",
  "Wave Period (s)" = "wave_period",
  "Wind Speed (m/s)" = "wind_speed",
  "Wind Gust (m/s)" = "gust",
  "Air Temperature (C)" = "air_temperature",
  "Sea Temperature (C)" = "sea_temperature",
  "Pressure (hPa)" = "atmospheric_pressure"
)

# Sort column choices for table
SORT_CHOICES <- c(
  "Time (newest)" = "time_desc",
  "Time (oldest)" = "time_asc",
  "Wave Height (high)" = "wave_height_desc",
  "Wave Height (low)" = "wave_height_asc",
  "Wind Speed (high)" = "wind_speed_desc",
  "Wind Speed (low)" = "wind_speed_asc",
  "Station" = "station_id_asc"
)

ui <- navbarPage(
  "Irish Weather Buoy Network",
  id = "main_nav",

  # === TAB 1: Time Series Explorer ===
  tabPanel(
    "Time Series",
    icon = icon("chart-line"),
    sidebarLayout(
      sidebarPanel(
        width = 3,
        selectInput(
          "stations",
          "Select Station(s):",
          choices = NULL,
          multiple = TRUE
        ),
        selectInput(
          "variable",
          "Select Variable:",
          choices = VAR_CHOICES,
          selected = "wave_height"
        ),
        sliderInput(
          "days",
          "Last N Days:",
          min = 1, max = 90, value = 7, step = 1
        ),
        hr(),
        h4("Station Info"),
        verbatimTextOutput("station_info"),
        hr(),
        h4("Summary Statistics"),
        verbatimTextOutput("summary_stats")
      ),
      mainPanel(
        width = 9,
        plotlyOutput("timeseries", height = "350px"),
        hr(),
        fluidRow(
          column(4, h4("Recent Observations")),
          column(4,
            selectInput("sort_by", "Sort by:",
                        choices = SORT_CHOICES, selected = "time_desc", width = "100%")
          ),
          column(4, align = "right",
            selectInput("n_rows", "Show rows:",
                        choices = c(10, 25, 50, 100), selected = 25, width = "100px")
          )
        ),
        p(tags$small("Click column headers to sort the table")),
        uiOutput("data_table_ui")
      )
    )
  ),

  # === TAB 2: Scatter Plot Comparison ===
  tabPanel(
    "Scatter Plot",
    icon = icon("chart-scatter"),
    sidebarLayout(
      sidebarPanel(
        width = 3,
        selectInput(
          "scatter_stations",
          "Select Station(s):",
          choices = NULL,
          multiple = TRUE
        ),
        selectInput(
          "var_x",
          "X-Axis Variable:",
          choices = VAR_CHOICES,
          selected = "wind_speed"
        ),
        selectInput(
          "var_y",
          "Y-Axis Variable:",
          choices = VAR_CHOICES,
          selected = "wave_height"
        ),
        sliderInput(
          "scatter_days",
          "Last N Days:",
          min = 1, max = 90, value = 7, step = 1
        ),
        hr(),
        h4("Correlation"),
        verbatimTextOutput("correlation")
      ),
      mainPanel(
        width = 9,
        plotlyOutput("scatter_plot", height = "500px")
      )
    )
  ),

  # === TAB 3: Notes & References ===
  tabPanel(
    "Notes",
    icon = icon("info-circle"),
    fluidPage(
      fluidRow(
        column(6,
          h2("About This Dashboard"),
          p("This interactive dashboard displays data from the ",
            tags$b("Irish Weather Buoy Network"),
            ", operated by the Marine Institute of Ireland."),
          h4("Features"),
          tags$ul(
            tags$li(tags$b("Time Series Tab:"), " View any variable over time for one or more stations"),
            tags$li(tags$b("Scatter Plot Tab:"), " Compare two variables to explore correlations"),
            tags$li(tags$b("Notes Tab:"), " Data sources, quality information, and references")
          ),
          hr(),
          h2("Data Sources"),
          p("Data sourced from the ",
            tags$a(href = "https://erddap.marine.ie/erddap/index.html",
                   "Marine Institute ERDDAP Server", target = "_blank")),
          p("The Irish Weather Buoy Network is operated by the Marine Institute of Ireland."),
          p("Historical data available from 2001 to present.")
        ),
        column(6,
          h2("Data Summary"),
          verbatimTextOutput("last_updated"),
          hr(),
          h2("Station Information"),
          uiOutput("station_table_ui")
        )
      ),

      hr(),
      h2("Data Quality"),
      fluidRow(
        column(6,
          h4("Quality Control Flags"),
          tags$ul(
            tags$li(tags$b("0"), " = Unverified data (raw sensor readings)"),
            tags$li(tags$b("1"), " = Good quality data (passed QC checks)"),
            tags$li(tags$b("9"), " = Missing data (sensor offline or invalid)")
          ),
          p("Current dataset excludes missing data (QC flag = 9).")
        ),
        column(6,
          h4("QC Flag Distribution"),
          uiOutput("qc_summary_ui"),
          h4("QC by Station"),
          uiOutput("qc_by_station_ui")
        )
      ),

      hr(),
      h2("Most Recent Observations"),
      p(tags$small("Click column headers to sort")),
      uiOutput("recent_obs_ui"),

      hr(),
      h2("References"),
      tags$ul(
        tags$li(tags$a(href = "https://www.marine.ie/", "Marine Institute Ireland", target = "_blank")),
        tags$li(tags$a(href = "https://erddap.marine.ie/", "ERDDAP Data Portal", target = "_blank")),
        tags$li(tags$a(href = "https://github.com/JohnGavin/irishbuoys", "irishbuoys R Package", target = "_blank"))
      ),

      hr(),
      h2("Technical Notes"),
      p("This dashboard runs entirely in your browser using WebR (R compiled to WebAssembly)."),
      p("Built with: Shiny, Plotly, Shinylive, Quarto"),
      p("Data updates: Weekly via GitHub Actions")
    )
  )
)

server <- function(input, output, session) {

  # Reactive value to store loaded data
  loaded_data <- reactiveVal(NULL)

  # Receive data from JavaScript
  observeEvent(input$js_buoy_data, {
    tryCatch({
      json_str <- input$js_buoy_data
      if (!is.null(json_str) && nchar(json_str) > 100) {
        data <- jsonlite::fromJSON(json_str)
        data$time <- as.POSIXct(data$time, format = "%Y-%m-%dT%H:%M:%SZ", tz = "UTC")
        loaded_data(data)
        message("Received ", nrow(data), " records from JavaScript")
      }
    }, error = function(e) {
      message("Error parsing JS data: ", e$message)
    })
  }, ignoreNULL = TRUE, ignoreInit = TRUE)

  # Main data reactive - use JS data or fallback
  buoy_data <- reactive({
    # Check if we have data from JavaScript
    data <- loaded_data()

    if (!is.null(data) && nrow(data) > 100) {
      return(data)
    }

    # Fallback to sample data while waiting for JS
    message("Using fallback sample data")
    n_days <- 90
    n_per_day <- 24
    n_stations <- 5
    n_total <- n_days * n_per_day * n_stations

    data.frame(
      time = rep(Sys.time() - (1:(n_days * n_per_day)) * 3600, n_stations),
      station_id = rep(c("M2", "M3", "M4", "M5", "M6"), each = n_days * n_per_day),
      wave_height = runif(n_total, 0.5, 8),
      hmax = runif(n_total, 1, 12),
      wave_period = runif(n_total, 4, 14),
      wind_speed = runif(n_total, 2, 30),
      gust = runif(n_total, 5, 40),
      air_temperature = runif(n_total, 3, 18),
      sea_temperature = runif(n_total, 7, 14),
      atmospheric_pressure = runif(n_total, 970, 1030),
      longitude = rep(c(-5.43, -10.55, -10.15, -9.99, -15.88), each = n_days * n_per_day),
      latitude = rep(c(53.48, 51.22, 53.07, 55.00, 53.06), each = n_days * n_per_day),
      qc_flag = rep(0, n_total)
    )
  })

  # Initialize station choices - update when data changes
  observe({
    data <- buoy_data()
    stations <- sort(unique(data$station_id))
    updateSelectInput(session, "stations", choices = stations, selected = stations)
    updateSelectInput(session, "scatter_stations", choices = stations, selected = stations)
  })

  # Re-trigger station update when real data loads
  observeEvent(loaded_data(), {
    data <- loaded_data()
    if (!is.null(data)) {
      stations <- sort(unique(data$station_id))
      updateSelectInput(session, "stations", choices = stations, selected = stations)
      updateSelectInput(session, "scatter_stations", choices = stations, selected = stations)
    }
  }, ignoreNULL = TRUE)

  # Filter data for time series tab
  filtered_data <- reactive({
    req(input$stations, input$days)
    data <- buoy_data()
    cutoff <- Sys.time() - (input$days * 24 * 3600)
    data |>
      filter(station_id %in% input$stations, time >= cutoff)
  })

  # Sorted filtered data
  sorted_data <- reactive({
    data <- filtered_data()
    if (nrow(data) == 0) return(data)

    sort_col <- input$sort_by
    if (sort_col == "time_desc") {
      data <- data[order(data$time, decreasing = TRUE), ]
    } else if (sort_col == "time_asc") {
      data <- data[order(data$time, decreasing = FALSE), ]
    } else if (sort_col == "wave_height_desc") {
      data <- data[order(data$wave_height, decreasing = TRUE, na.last = TRUE), ]
    } else if (sort_col == "wave_height_asc") {
      data <- data[order(data$wave_height, decreasing = FALSE, na.last = TRUE), ]
    } else if (sort_col == "wind_speed_desc") {
      data <- data[order(data$wind_speed, decreasing = TRUE, na.last = TRUE), ]
    } else if (sort_col == "wind_speed_asc") {
      data <- data[order(data$wind_speed, decreasing = FALSE, na.last = TRUE), ]
    } else if (sort_col == "station_id_asc") {
      data <- data[order(data$station_id, data$time, decreasing = c(FALSE, TRUE)), ]
    }
    data
  })

  # Filter data for scatter tab
  scatter_data <- reactive({
    req(input$scatter_stations, input$scatter_days)
    data <- buoy_data()
    cutoff <- Sys.time() - (input$scatter_days * 24 * 3600)
    data |>
      filter(station_id %in% input$scatter_stations, time >= cutoff) |>
      arrange(desc(time))
  })

  # Station info
  output$station_info <- renderText({
    data <- filtered_data()
    if (nrow(data) == 0) return("No data available")

    paste0(
      "Stations: ", paste(unique(data$station_id), collapse = ", "), "\n",
      "Records: ", format(nrow(data), big.mark = ","), "\n",
      "From: ", format(min(data$time), "%Y-%m-%d %H:%M"), "\n",
      "To: ", format(max(data$time), "%Y-%m-%d %H:%M")
    )
  })

  # Summary statistics
  output$summary_stats <- renderText({
    data <- filtered_data()
    var <- input$variable
    if (nrow(data) == 0 || !var %in% names(data)) return("No data")

    values <- data[[var]]
    values <- values[!is.na(values)]
    if (length(values) == 0) return("No valid data")

    var_label <- names(VAR_CHOICES)[VAR_CHOICES == var]
    paste0(
      "Variable: ", var_label, "\n",
      "Min: ", round(min(values), 2), "\n",
      "Max: ", round(max(values), 2), "\n",
      "Mean: ", round(mean(values), 2), "\n",
      "SD: ", round(sd(values), 2)
    )
  })

  # Time series plot
  output$timeseries <- renderPlotly({
    data <- filtered_data()
    var <- input$variable

    if (nrow(data) == 0 || !var %in% names(data)) {
      return(plot_ly() |> layout(title = "No data available"))
    }

    var_label <- names(VAR_CHOICES)[VAR_CHOICES == var]

    p <- plot_ly()
    for (stn in unique(data$station_id)) {
      stn_data <- data[data$station_id == stn, ]
      stn_data <- stn_data[order(stn_data$time), ]
      p <- p |> add_trace(
        data = stn_data,
        x = ~time, y = ~get(var),
        type = "scatter", mode = "lines+markers",
        name = stn,
        marker = list(size = 3),
        hovertemplate = paste0("<b>", stn, "</b><br>%{x}<br>", var_label, ": %{y:.2f}<extra></extra>")
      )
    }

    p |> layout(
      title = paste(var_label, "- Last", input$days, "Days"),
      xaxis = list(title = "Time (UTC)"),
      yaxis = list(title = var_label),
      hovermode = "x unified",
      legend = list(orientation = "h", y = -0.2)
    )
  })

  # Helper function to create sortable table HTML
  make_sortable_table <- function(df, digits = 2) {
    if (nrow(df) == 0) return(tags$p("No data available"))

    # Round numeric columns
    for (col in names(df)) {
      if (is.numeric(df[[col]])) {
        df[[col]] <- round(df[[col]], digits)
      }
    }

    # Create table with sortable class
    tags$table(
      class = "table table-striped table-hover sortable",
      tags$thead(
        tags$tr(
          lapply(names(df), function(col) tags$th(col))
        )
      ),
      tags$tbody(
        lapply(1:nrow(df), function(i) {
          tags$tr(
            lapply(df[i, ], function(val) tags$td(as.character(val)))
          )
        })
      )
    )
  }

  # Data table with sorting
  output$data_table_ui <- renderUI({
    data <- sorted_data()
    if (nrow(data) == 0) return(tags$p("No data"))

    n <- as.integer(input$n_rows)
    display_data <- data |>
      head(n) |>
      mutate(time = format(time, "%Y-%m-%d %H:%M")) |>
      select(time, station_id, wave_height, hmax, wave_period, wind_speed, gust)

    make_sortable_table(display_data)
  })

  # Scatter plot
  output$scatter_plot <- renderPlotly({
    data <- scatter_data()
    var_x <- input$var_x
    var_y <- input$var_y

    if (nrow(data) == 0) {
      return(plot_ly() |> layout(title = "No data available"))
    }

    x_label <- names(VAR_CHOICES)[VAR_CHOICES == var_x]
    y_label <- names(VAR_CHOICES)[VAR_CHOICES == var_y]

    plot_ly(data, x = ~get(var_x), y = ~get(var_y),
            color = ~station_id,
            type = "scatter", mode = "markers",
            marker = list(size = 6, opacity = 0.6),
            hovertemplate = paste0(
              "<b>%{data.name}</b><br>",
              x_label, ": %{x:.2f}<br>",
              y_label, ": %{y:.2f}<extra></extra>"
            )) |>
      layout(
        title = paste(y_label, "vs", x_label, "- Last", input$scatter_days, "Days"),
        xaxis = list(title = x_label),
        yaxis = list(title = y_label),
        legend = list(orientation = "h", y = -0.15)
      )
  })

  # Correlation
  output$correlation <- renderText({
    data <- scatter_data()
    var_x <- input$var_x
    var_y <- input$var_y

    if (nrow(data) < 3) return("Insufficient data")

    x_vals <- data[[var_x]]
    y_vals <- data[[var_y]]
    valid <- !is.na(x_vals) & !is.na(y_vals)

    if (sum(valid) < 3) return("Insufficient valid data")

    cor_val <- cor(x_vals[valid], y_vals[valid])
    paste0("Pearson r = ", round(cor_val, 3), "\n",
           "n = ", format(sum(valid), big.mark = ","), " observations")
  })

  # Notes tab outputs
  output$last_updated <- renderText({
    data <- buoy_data()
    real_data <- loaded_data()
    is_real <- !is.null(real_data) && nrow(real_data) > 100
    days_span <- as.numeric(difftime(max(data$time), min(data$time), units = "days"))
    paste0(
      "Data source: ", ifelse(is_real, "ERDDAP JSON (real data)", "Sample data (loading...)"), "\n",
      "Date range: ", format(min(data$time), "%Y-%m-%d %H:%M"), " to ",
      format(max(data$time), "%Y-%m-%d %H:%M"), " UTC\n",
      "Time span: ", round(days_span, 1), " days\n",
      "Total records: ", format(nrow(data), big.mark = ","), "\n",
      "Stations: ", paste(sort(unique(data$station_id)), collapse = ", ")
    )
  })

  output$recent_obs_ui <- renderUI({
    data <- buoy_data()
    display_data <- data |>
      arrange(desc(time)) |>
      head(15) |>
      mutate(time = format(time, "%Y-%m-%d %H:%M")) |>
      select(time, station_id, wave_height, hmax, wind_speed, gust, air_temperature)

    make_sortable_table(display_data)
  })

  output$station_table_ui <- renderUI({
    data <- buoy_data()
    display_data <- data |>
      group_by(station_id) |>
      summarise(
        Records = n(),
        Lat = round(first(latitude), 2),
        Lon = round(first(longitude), 2),
        .groups = "drop"
      )

    make_sortable_table(display_data, digits = 2)
  })

  # QC Flag tables
  output$qc_summary_ui <- renderUI({
    data <- buoy_data()
    if (!"qc_flag" %in% names(data)) {
      return(tags$p("QC flag data not available"))
    }
    qc_counts <- as.data.frame(table(data$qc_flag, useNA = "ifany"))
    names(qc_counts) <- c("QC_Flag", "Count")
    qc_counts$Percentage <- paste0(round(100 * qc_counts$Count / sum(qc_counts$Count), 1), "%")
    qc_counts$Description <- ifelse(qc_counts$QC_Flag == 0, "Unverified",
                             ifelse(qc_counts$QC_Flag == 1, "Good quality",
                             ifelse(qc_counts$QC_Flag == 9, "Missing", "Other")))
    display_data <- qc_counts[, c("QC_Flag", "Description", "Count", "Percentage")]

    make_sortable_table(display_data, digits = 0)
  })

  output$qc_by_station_ui <- renderUI({
    data <- buoy_data()
    if (!"qc_flag" %in% names(data)) {
      return(tags$p("QC flag data not available"))
    }
    display_data <- data |>
      group_by(station_id, qc_flag) |>
      summarise(Count = n(), .groups = "drop") |>
      tidyr::pivot_wider(names_from = qc_flag, values_from = Count, values_fill = 0) |>
      rename(Station = station_id)

    make_sortable_table(display_data, digits = 0)
  })
}

shinyApp(ui, server)
```
